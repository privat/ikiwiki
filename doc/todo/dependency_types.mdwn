Ikiwiki currently only has one type of dependency between pages
(plus wikilinks special cased in on the side). This has resulted in various
problems, and it's seemed for a long time to me that ikiwiki needs to get
smarter about what types of dependencies are supported.

### unnecessary work

The current single dependency type causes the depending page to be rebuilt
whenever a matching dependency is added, removed, or *modified*. But a
great many things don't care about the modification case, and often cause
unnecessary page rebuilds:

* map only cares if the pages are added or removed. Content change does
  not matter (unless show=title is used).
* brokenlinks, orphans, pagecount, ditto (generally)
* inline in archive mode cares about page title, author changing, but
  not content. (Ditto for meta with show=title.)
* Causes extra work when solving the [[bugs/transitive_dependencies]]
  problem.

### two types of dependencies needed for [[tracking_bugs_with_dependencies]]

>>  it seems that there are two types of dependency, and ikiwiki
>>  currently only handles one of them.  The first type is "Rebuild this
>>  page when any of these other pages changes" - ikiwiki handles this.
>>  The second type is "rebuild this page when set of pages referred to by
>>  this pagespec changes" - ikiwiki doesn't seem to handle this.  I
>>  suspect that named pagespecs would make that second type of dependency
>>  more important.  I'll try to come up with a good example. -- [[Will]]

>>> Hrm, I was going to build an example of this with backlinks, but it
>>> looks like that is handled as a special case at the moment (line 458 of
>>> render.pm).  I'll see if I can breapk
>>> things another way.  Fixing this properly would allow removal of that special case. -- [[Will]]

>>>> I can't quite understand the distinction you're trying to draw
>>>> between the two types of dependencies. Backlinks are a very special
>>>> case though and I'll be suprised if they fit well into pagespecs.
>>>> --[[Joey]] 

>>>>> The issue is that the existential pagespec matching allows you to build things that have similar
>>>>> problems to backlinks.
>>>>> e.g. the following inline:

    \[[!inline pages="define(~done, link(done)) and link(~done)" archive=yes]]

>>>>> includes any page that links to a page that links to done.  Now imagine I add a new link to 'done' on
>>>>> some random page somewhere - a page which some other page links to which didn't previously get included - the set of pages accepted by the pagespec, and hence the set of
>>>>> pages inlined, will change.  But, there is no dependency anywhere on the page that I altered, so
>>>>> ikiwiki will not rebuild the page with the inline in it.  What is happening is that the page that I altered affects
>>>>> the set of pages matched by the pagespec without itself being matched by the pagespec, and hence included in the dependency list.

>>>>> To make this work well, I think you need to recognise two types of dependencies for each page (and no
>>>>> special cases for particular types of links, eg backlinks).  The first type of dependency says, "The content of
>>>>> this page depends upon the content of these other pages".  The `add_depends()` in the shortcuts
>>>>> plugin is of this form: any time the shortcuts page is edited, any page with a shortcut on it
>>>>> is rebuilt.  The inline plugin also needs to add dependencies of this form to detect when the inlined
>>>>> content changes.  By contrast, the map plugin does not need a dependency of this form, because it
>>>>> doesn't actually care about the content of any pages, just which pages it needs to include (which we'll handle next).

>>>>> The second type of dependency says, "The content of this page depends upon the exact set of pages matched
>>>>> by this pagespec".  The first type of dependency was about the content of some pages, the second type is about
>>>>> which pages get matched by a pagespec.  This is the type of dependency tracking that the map plugin needs.
>>>>> If the set of pages matched by map pagespec changes, then the page with the map on it needs to be rebuilt to show a different list of pages.
>>>>> Inline needs this type of dependency as well as the previous type - This type handles a change in which pages
>>>>> are inlined, the previous type handles a change in the content of any of those pages.  Shortcut does not need this type of
>>>>> dependency.  Most of the places that use `add_depends()` seem to need this type of dependency rather than the first type.

>>>>>> Note that inline and map currently achieve the second type of dependency by
>>>>>> explicitly calling `add_depends` for each page the displayed.
>>>>>> If any of those pages are removed, the regular pagespec would not
>>>>>> match them -- since they're gone. However, the explicit dependency
>>>>>> on them does cause them to match. It's an ugly corner I'd like to
>>>>>> get rid of. --[[Joey]]

>>>>> Implementation Details:  The first type of dependency can be handled very similarly to the current
>>>>> dependency system.  You just need to keep a list of pages that the content depends upon.  You could
>>>>> keep that list as a pagespec, but if you do this you might want to check that the pagespec doesn't change,
>>>>> possibly by adding a dependency of the second type along with the dependency of the first type.

>>>>>> An example of the current system not tracking enough data is 
>>>>>> described in [[bugs/transitive_dependencies]].
>>>>>> --[[Joey]] 

>>>>> The second type of dependency is a little more tricky.  For each page, we'd need a list of pagespecs that
>>>>> the page depended on, and for each pagespec you'd want to store the list of pages that currently match it.
>>>>> On refresh, you'd need to check each pagespec to see if the set of pages that match it has changed, and if
>>>>> that set has changed, then rebuild the dependent page(s).  Oh, and for this second type of dependency, I
>>>>> don't think you can merge pagespecs.  If I wanted to know if either "\*" or "link(done)" changes, then just checking
>>>>> to see if the set of pages matched by "\* or link(done)" changes doesn't work.

>>>>> The current system works because even though you usually want dependencies of the second type, the set of pages
>>>>> referred to by a pagespec can only change if one of those pages itself changes.  i.e. A dependency check of the
>>>>> first type will catch a dependency change of the second type with current pagespecs.
>>>>> This doesn't work with backlinks, and it doesn't work with existential matching.  Backlinks are currently special-cased.  I don't know
>>>>> how to special-case existential matching - I suspect you're better off just getting the dependency tracking right.

>>>>> I also tried to come up with other possible solutions: e.g. can we find the dependencies for a pagespec?  That
>>>>> would be the set of pages where a change on one of those pages could lead to a change in the set of pages matched by the pagespec.
>>>>> For old-style pagespecs without backlinks, the dependency set for a pagespec is the same as the set of pages the pagespec matches.
>>>>> Unfortunately, with existential matching, the set of pages that each
>>>>> pagespec depends upon can quickly become "*", which is not very useful.  -- [[Will]]

### proposal

I propose the following. --[[Joey]] 

* Add a second type of dependency, call it an "presence dependency".
* `add_depends` defaults to adding a regular ("full") dependency, as
  before. (So nothing breaks.)
* `add_depends($page, $spec, presence => 0)` adds an presence dependency.
* `refresh` only looks at added/removed pages when resolving presence
  dependencies.

This seems straightforwardly doable. I'd like [[Will]]'s feedback on it, if
possible. The type types of dependencies I am proposing are not identical
to the two types he talks about above, but I hope are close enough that
they can be used.

This doesn't deal with the stuff that only depend on the metadata of a
page, as collected in the scan pass, changing.  But it does leave a window
open for adding such a dependency type later.

----

I implemented the above in a branch.
[[!template id=gitbranch branch=origin/dependency-types author="[[joey]]"]]

Then I found some problems:

* Something simple like pagecount, that seems like it could use a
  presence dependency, can have a pagespec that uses metadata, like
  `author()` or `copyright()`.
* pagestats, orphans and brokenlinks cannot use presence dependencies
  because they need to update when links change.

Now I'm thinking about having a special dependency look at page
metadata, and fire if the metadata changes. And it seems links should
either be included in that, or there should be a way to make a dependency
that fires when a page's links change. (And what about backlinks?)

It's easy to see when a page's links change, since there is `%oldlinks`.
To see when metadata is changed is harder, since it's stored in the
pagestate by the meta plugin. Also, there are many different types of
metadata, that would need to be matched with the pagespecs somehow.

Quick alternative: Make add_depends look at the pagespec. Ie, if it
is a simple page name, or a glob, we know a presence dependency
can be valid. If's more complex, convert the dependency from
presence to full.

There is a lot to dislike about this method. Its parsing of the pagespec,
as currently implemented, does not let plugins add new types of pagespecs
that only care about presence. Its pagespec parsing is also subject to
false negatives (though these should be somewhat rare, and no false
positives). Still, it does work, and it makes things like simple maps and
pagecounts much more efficient.

----

#### Will's first pass feedback.

If the API is going to be updated, then it would be good to make it forward compatible.
I'd like for the API to be extendible to what is useful for complex pagespecs, even if we
that is a little redundant at the moment.

My attempt to play with this is in my git repo.  [[!template id=gitbranch branch=origin/depends-spec author="[[will]]"]]
That branch is a little out of date, but if you just look at the changes in IkiWiki.pm you'll see the concept I was looking at.
I added an "add_depends_spec()" function that adds a dependency on the pagespec passed to it.  If the set of matched pages
changes, then the dependent page is rebuilt.  At the moment the implementation uses the same hack used by map and inline -
just add all the pages that currently exist as traditional content dependencies.

> As I note below, a problem with this approach is that it has to try
> matching the pagespec against every page, redundantly with the work done
> by the plugin. (But there are ways to avoid that redundant matching.)
> --[[Joey]]

Getting back to commenting on your proposal:

Just talking about the definition of a "presence dependency" for the moment, and ignoring implementation.  Is a
"presence dependency" supposed to cause an update when a page disappears?  I assume so.  Is a presence dependency
supposed to cause an update when a pages existence hasn't changed, but it no longer matches the pagespec.
(e.g. you use `created_before(test_page)` in a pagespec, and there was a page, `new_page`, that was created
after `test_page`.  `new_page` will not match the spec.  Now we'll delete and then re-create `test_page`.  Now
`new_page` will match the spec, and yet `new_page` itself hasn't changed.  Nor has its 'presence' - it was present
before and it is present now.  Should this cause a re-build of any page that has a 'presence' dependency on the spec?

> Yes, a presence dep will trigger when a page is added, or removed.

> Your example is valid.. but it's also not handled right by normal,
> (content) dependencies, for the same reasons. --[[Joey]]

I think that is another version of the problem you encountered with meta-data.

In the longer term I was thinking we'd have to introduce a concept of 'internal pagespec dependencies'.  Note that I'm
defining 'internal' pagespec dependencies differently to the pagespec dependencies I defined above.  Perhaps an example:
If you had a pagespec that was `created_before(test_page)`, then you could list all pages created before `test_page`
with a `map` directive.  The map directive would add a pagespec dependency on `created_before(test_page)`.
Internally, there would be a second page-spec parsing function that discovers which pages a given pagespec
depends on.  As well as the function `match_created_before()`, we'd have to add a new function `depend_created_before()`.
This new function would return a list of pages, which when any of them change, the output of `match_created_before()`
would change.  In this example, it would just return `test_page`.

These lists of dependent pages could just be concatenated for every `match_...()` function in a pagespec - you can ignore
the boolean formula aspects of the pagespec for this.  If a content dependency were added on these pages, then I think 
the correct rebuilds would occur.  

In all, this is a surprisingly difficult problem to solve perfectly.  Consider the following case:

PageA.mdwn:

> [ShavesSelf]

PageB.mdwn

> Doesn't shave self.

ShavedByBob.mdwn:

> [!include pages="!link(ShavesSelf)"]

Does ShavedByBob.mdwn include itself?

(Yeah - in IkiWiki currently links are included by include, but the idea holds.  I had a good example a while back, but I can't think of it right now.)

sigh.

-- [[Will]]

> I have also been thinking about some sort of analysis pass over pagespecs
> to determine what metadata, pages, etc they depend on. It is indeed
> tricky to do. Even if it's just limited to returning a list of pages
> as you suggest.
>
> Consider: For a `*` glob, it has to return a list of all pages
> in the wiki. Which is expensive. And what if the pagespec is
> something like `* and backlink(index)`? Without analyising the
> boolean relationship between terms, the returned list
> will have many more items in it than it should. Or do we not make
> globs return their matches? (If so we have to deal with those
> with one of the other methods disucssed.) --[[Joey]]

---- 

### Link dependencies

* `add_depends($page, $spec, links => 1, presence => 1)`
  adds a links + presence dependency.
* `refresh` only rebuilds a page with a links dependency if
  pages matched by the pagespec gain or lose links. (What the link
  actually points to may change independent of this, due to changes
  elsewhere, without it firing.)
* So, brokenlinks can fire whenever any links in any of the
  pages it's tracking change, or when pages are added or
  removed.
* To determine if a pagespec is valid to be used with a links dependency,
  use the same set that are valid for presence dependencies. But also
  allow `backlinks()` to be used in it, since that matches pages
  that the page links to, which is just what link dependencies are
  triggered on.

----

### the removal problem

So far I have not addressed fixing the removal problem (which Will
discusses above).

Summary of problem: A has a dependency on a pagespec such as
"bugs/* and !link(done)". B currently matches. Then B is updated,
in a way that makes A's dependency not match it (ie, it links to done).
Now A is not updated, because ikiwiki does not realize that it
depended on B before.

This was worked around to fix [[bugs/inline_page_not_updated_on_removal]]
by inline and map adding explicit dependencies on each page that appears
on them. Then a change to B triggers the explicit dep. While this works,
it's 1) ugly 2) probably not implemented by all plugins that could
be affected by this problem (ie, linkmap) and 3) is most of the reason why
we grew the complication of `depends_simple`.

One way to fix this is to include with each dependency, a list of pages
that currently match it. If the list changes, the dependency is triggered.

Should be doable, but may involve more work than
currently. Consider that a dependency on "bugs/*" currently
is triggered by just checking until *one* page is found to match it.
But to store the list, *every* page would have to be tried against it.
Unless the list can somehow be intelligently updated, looking at only the
changed pages.

----

What if there were a function that added a dependency, and at the same time
returned a list of pages matching the pagespec? Plugins that use this would
be exactly the ones, like inline and map, for which this is a problem, and
which already do a match pass over all pages.

Adding explicit dependencies during this pass would thus be nearly free.
Not 100% free since it would add explicit deps for things that are not
shown on an inline that limits its display to the first sorted N items.
I suppose we could reach 100% free by making the function also handle
sorting and limiting, though that could be overkill.
